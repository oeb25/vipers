use std::{
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
    process::{Command, Stdio},
};

use color_eyre::{eyre::bail, Result};
use heck::ToSnakeCase;
use itertools::Itertools;
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};
use regex::Regex;

#[test]
#[ignore]
fn generate_cli() -> Result<()> {
    color_eyre::install()?;

    let viperserver_path = PathBuf::from(concat!(env!("CARGO_MANIFEST_DIR"), "/viperserver/"));
    let carbon_path = viperserver_path.join("carbon");
    let silicon_path = viperserver_path.join("silicon");

    let viperserver_help =
        compile_and_run_help(&viperserver_path, "viperserver.jar", "ViperServerOpts")?;
    let carbon_help = compile_and_run_help(&carbon_path, "carbon.jar", "CarbonOpts")?;
    let silicon_help = compile_and_run_help(&silicon_path, "silicon.jar", "SiliconOpts")?;

    let output_path = PathBuf::from(concat!(env!("CARGO_MANIFEST_DIR"), "/src/generated.rs"));

    let mut output = File::create(&output_path)?;

    writeln!(
        output,
        "//! Generated by `generate_cli`, do not edit by hand."
    )?;

    writeln!(output, "use derive_builder::Builder;")?;

    writeln!(output, "{viperserver_help}")?;
    writeln!(output, "{carbon_help}")?;
    writeln!(output, "{silicon_help}")?;

    Command::new("rustfmt").arg(output_path).output()?;

    Ok(())
}

fn compile_and_run_help(p: &Path, jar_name: &str, opts_name: &str) -> Result<TokenStream> {
    eprintln!("> compiling {p:?}");
    let output = Command::new("sbt")
        .arg("assembly")
        .arg("--error")
        .current_dir(p)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .output()?;
    if !output.status.success() {
        bail!("failed to compile {jar_name:?}");
    }

    eprintln!("> running --help in {p:?}");
    let target_path = fs::read_dir(p.join("target/"))?
        .map(|p| p.unwrap())
        .find(|p| p.file_name().to_str().unwrap().starts_with("scala-"))
        .unwrap()
        .path();
    dbg!(&target_path);
    let output = Command::new("java")
        .arg("-jar")
        .arg(target_path.join(jar_name))
        .arg("--help")
        .stderr(Stdio::inherit())
        .output()?;
    // if !output.status.success() {
    //     bail!("failed to run help for {jar_name:?}");
    // }
    parse_help(
        &String::from_utf8(output.stdout)?,
        format_ident!("{opts_name}"),
    )
}

fn parse_help(help: &str, opts_name: Ident) -> Result<TokenStream> {
    let option_regex = Regex::new(r"(-[a-z0-9],\s+)?--([a-zA-Z0-9]+)(\s+<arg>\.*)?")?;

    let (struct_fields, display_impl, args_fn): (Vec<_>, Vec<_>, Vec<_>) = option_regex
        .find_iter(help)
        .tuple_windows()
        .map(|(a, b)| {
            let option = option_regex.captures(a.as_str()).unwrap();
            // let short = option.get(1).map(|s| &s.as_str()[1..2]);
            let long = option.get(2).unwrap().as_str();
            let arg = option.get(3).map(|s| s.as_str());

            let description = help[a.end()..b.start()]
                .trim()
                .lines()
                .map(|l| l.trim())
                .join(" ");

            let description = format!("`{}`\n\n{description}", a.as_str());

            let name = format_ident!("{}", long.to_snake_case());

            let opt_flag = format!("--{long}");

            if arg.is_some() {
                let opt = format!("{opt_flag} {{value}} ");
                (
                    quote! {
                        #[doc = #description]
                        #[builder(setter(into, strip_option), default)]
                        pub #name: Option<String>,
                    },
                    quote! {
                        if let Some(value) = &self.#name {
                            write!(f, #opt)?;
                        }
                    },
                    quote! {
                        if let Some(value) = &self.#name {
                            f(#opt_flag);
                            f(value);
                        }
                    },
                )
            } else {
                let opt_flag_space = format!("{opt_flag} ");
                (
                    quote! {
                        #[doc = #description]
                        #[builder(setter(strip_option), default)]
                        pub #name: Option<bool>,
                    },
                    quote! {
                        if let Some(true) = &self.#name {
                            write!(f, #opt_flag_space)?;
                        }
                    },
                    quote! {
                        if let Some(true) = &self.#name {
                            f(#opt_flag);
                        }
                    },
                )
            }
        })
        .multiunzip();

    Ok(quote! {
        #[derive(Debug, Clone, Builder, Default)]
        pub struct #opts_name {
            #(#struct_fields)*
        }
        impl std::fmt::Display for #opts_name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                #(#display_impl)*
                Ok(())
            }
        }
        impl #opts_name {
            pub fn apply(&self, mut f: impl FnMut(&str)) {
                #(#args_fn)*
            }
        }
    })
}
